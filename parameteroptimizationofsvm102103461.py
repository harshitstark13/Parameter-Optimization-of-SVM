# -*- coding: utf-8 -*-
"""ParameterOptimizationofSVM102103461.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y0bEdNO0DBE0QhbjwhFBR_bDn3xuWlVd

## Parameter Optimization of SVM

Name: Harshit

Roll No.: 102103461

# Importing Libraries
"""

!pip install bayesian-optimization
!pip install ucimlrepo

# Importing necessary libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.svm import NuSVC
from sklearn.metrics import accuracy_score
from bayes_opt import BayesianOptimization
from ucimlrepo import fetch_ucirepo

"""# Fetching and Organizing Dataset"""

# Fetching dataset
dry_bean = fetch_ucirepo(id=602)

# Organizing data
X = dry_bean.data.features
y = dry_bean.data.targets

# Splitting data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y.to_numpy().ravel(), test_size=0.3, random_state=42)

"""# Defining Optimization Parameter Ranges"""

# Defining optimization parameter ranges
kernels = ['rbf', 'poly', 'linear']
pbounds = {'kernel': (0, len(kernels)-1),
           'nu': (0.01, 0.1),
           'tol': (1e-6, 1.0)}

"""# Function for Evaluating SVM"""

# Function to evaluate SVM with given parameters
def evaluate_svm(kernel, nu, tol):
    kernel_name = kernels[int(kernel)]
    model = NuSVC(kernel=kernel_name, nu=nu, tol=tol)
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    return accuracy

"""# Bayesian Optimization for Multiple Samples"""

# Performing Bayesian Optimization for multiple samples
results = []
targets = []
iteration_counts = []

for sample in range(10):
    optimizer = BayesianOptimization(evaluate_svm, pbounds)
    optimizer.maximize(init_points=5, n_iter=100)
    best_params = optimizer.max['params']
    best_accuracy = optimizer.max['target']
    results.append((sample, best_accuracy, best_params))

    # Storing target values and iteration counts
    targets.append(optimizer._space.target)
    iteration_counts.append(optimizer._space.params.shape[0])

"""# Visualization of Convergence Plots"""

# Visualizing convergence plots for each sample with scatter plot
plt.figure(figsize=(12, 8))
for i in range(10):
    plt.scatter(range(iteration_counts[i]), targets[i][:iteration_counts[i]], label=f"Sample {i+1}", marker='o')

    # Connect points with lines
    plt.plot(range(iteration_counts[i]), targets[i][:iteration_counts[i]], linestyle='-', alpha=0.5)

plt.xlabel('Iterations')
plt.ylabel('Accuracy')
plt.title('Convergence Plot for Multiple Samples')
plt.legend()
plt.grid(True)
plt.show()

"""# Creating DataFrame for Results"""

# Creating DataFrame to display results
table = pd.DataFrame(results, columns=['Sample', 'Best Accuracy', 'Best SVM Parameter'])
print(table)

"""# Finding Sample with Maximum Accuracy"""

# Finding sample with maximum accuracy
max_accuracy_sample = table.loc[table['Best Accuracy'].idxmax()]
print(f"\nSample with maximum accuracy: {max_accuracy_sample['Sample']}")

"""# Plotting Convergence for Maximum Accuracy Sample"""

# Plotting convergence for sample with maximum accuracy
max_accuracy_optimizer_idx = max_accuracy_sample['Sample']
plt.figure(figsize=(8, 6))
plt.plot(range(iteration_counts[max_accuracy_optimizer_idx]),
         targets[max_accuracy_optimizer_idx][:iteration_counts[max_accuracy_optimizer_idx]], color='green')
plt.xlabel('Iterations')
plt.ylabel('Accuracy')
plt.title('Convergence Plot for Sample with Maximum Accuracy')
plt.grid(True)
plt.show()